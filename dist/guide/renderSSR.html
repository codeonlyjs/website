<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- HTML Meta Tags -->
    <title>CodeOnlyJS </title>
    <meta name="description" content="The front-end Web framework for coders." />
    <!-- Google / Search Engine Tags -->
    <meta itemprop="name" content="CodeOnlyJS " />
    <meta itemprop="description" content="The front-end Web framework for coders" />
    <meta itemprop="image" content="https://codeonlyjs.org/social-card-dark-1200.png" />
    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://codeonlyjs.org/" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="CodeOnlyJS " />
    <meta property="og:description" content="The front-end Web framework for coders" />
    <meta property="og:image" content="https://codeonlyjs.org/social-card-dark-1200.png" />
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="CodeOnlyJS " />
    <meta name="twitter:description" content="The front-end Web framework for coders" />
    <meta name="twitter:image" content="https://codeonlyjs.org/social-card-dark-1200.png" />
    <!-- Apple -->
    <link rel="apple-touch-icon" href="https://codeonlyjs.org/codeonly-icon-256.png" />
    <!-- Meta Tags Generated via https://heymeta.com -->

    <link href="https://cdn.jsdelivr.net/gh/codeonlyjs/stylish@1.0.10/stylish.css" type="text/css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/gh/codeonlyjs/stylish@1.0.10/stylish-theme.min.js"></script>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/css.min.js"></script>
    <link id="hljs-theme" href="" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/vs/loader.js"></script>
    <script>
    require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.0/min/vs' } });
    </script>
    <script>
    function updateHighlightTheme()
    {
        let el = document.getElementById("hljs-theme");
        let themeFile = stylish.darkMode ? "github-dark.min.css" : "github.min.css";
        let new_href = `https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/${themeFile}`;
        el.setAttribute("href", new_href);
    }
    stylish.addEventListener("darkModeChanged", updateHighlightTheme);
    updateHighlightTheme();
    </script>
    <style>
    :root
    {
        --dark-accent-color: #9D79E5;
    }
    :root.home-colors
    {
        --dark-body-back-color: #0a0b1a;
        --light-body-back-color: white;
    }
    body
    {
        padding: 0;
        margin: 0;
    }
    </style>
    <script type="module" crossorigin="crossorigin" src="/assets/index-CXDn6ClS.js"></script>
    <!--co-ssr-start--><link href="/assets/styles-AAABk3beHUc.css" type="text/css" rel="stylesheet" /><!--co-ssr-end-->
    <meta name="co-ssr" value="true" />
  </head>
  <body>
    <!--co-ssr-start-->
    <div id="layoutRoot">
      <header id="header">
        <a href="/" class="title"><img class="hide-sm" src="/public/codeonly-logo-light.svg" /><img class="hide-lg" src="/public/codeonly-icon.svg" /></a>
        <div class="buttons">
          <a href="/guide/" class="subtle button">Docs</a><a href="/lab" class="subtle button labLink vcenter"><svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="0 -960 960 960" preserveAspectRatio="xMidYMid slice" role="img"><path xmlns="http://www.w3.org/2000/svg" d="M200-120q-51 0-72.5-45.5T138-250l222-270v-240h-40q-17 0-28.5-11.5T280-800q0-17 11.5-28.5T320-840h320q17 0 28.5 11.5T680-800q0 17-11.5 28.5T640-760h-40v240l222 270q32 39 10.5 84.5T760-120H200Zm0-80h560L520-492v-268h-80v268L200-200Zm280-280Z"></path></svg> The Lab</a><input type="checkbox" class="theme-switch" />
          <script>
          document.querySelector(".theme-switch").checked = window.stylish.darkMode;
          </script>
        </div>
      </header>
      <div id="layoutDocumentation">
        <header id="mobile-bar"><button id="side-panel-menu-button" class="subtle muted"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 -960 960 960" preserveAspectRatio="xMidYMid slice" role="img"><path xmlns="http://www.w3.org/2000/svg" d="M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z"></path></svg> Menu</button><button id="side-panel-menu-button" class="subtle muted">On this page ›</button></header>
        <div id="div-wrapper">
          <div id="backdrop" class=""></div>
          <div id="div-lhs" class="">
            <nav id="nav-main">
              <!-- enter foreach block -->
              <h5> Introduction</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="." class="">Welcome</a></li>
                <li><a href="start" class="">Getting Started</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Components</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="components" class="">Overview</a></li>
                <li><a href="component" class="">API</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Templates</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="templates" class="">Basics</a></li>
                <li><a href="templateText" class="">Text and HTML</a></li>
                <li><a href="templateHtmlElements" class="">HTML Elements</a></li>
                <li><a href="templateComponents" class="">Component References</a></li>
                <li><a href="templateIf" class="">If Directive</a></li>
                <li><a href="templateForEach" class="">ForEach Directive</a></li>
                <li><a href="templateEmbedSlots" class="">Embed Slots</a></li>
                <li><a href="templateInput" class="">Input Bindings</a></li>
                <li><a href="templateTransitions" class="">Transitions</a></li>
                <li><a href="templateFluent" class="">Fluent Templates</a></li>
                <li><a href="templateUpdateSemantics" class="">Update Semantics</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Router</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="routerBasics" class="">Basics</a></li>
                <li><a href="routerDetails" class="">Details</a></li>
                <li><a href="routerNotes" class="">Notes</a></li>
                <li><a href="routerTypical" class="">Typical Setup</a></li>
                <li><a href="router" class="">API</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Rendering</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="renderIntro" class="">Introduction</a></li>
                <li><a href="renderSSR" class="">Server Side Rendering (SSR)</a></li>
                <li><a href="renderSSG" class="">Static Site Generation (SSG)</a></li>
                <li><a href="renderStatic" class="">Static Rendering</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Utilities</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="utilities" class="">Utilities</a></li>
                <li><a href="Notify" class="">Notify Service</a></li>
                <!-- leave foreach block -->
              </ul>
              <h5> Related</h5>
              <ul>
                <!-- enter foreach block -->
                <li><a href="stylish" class="">Stylish CSS</a></li>
                <li><a href="bundle-free" class="">Bundle Free</a></li>
                <li><a href="cogent" class="">Cogent</a></li>
                <!-- leave foreach block -->
              </ul>
              <!-- leave foreach block -->
            </nav>
          </div>
          <div id="div-center">
            <div class="document-view">
              <h1>Server Side Rendering</h1>
              <p>Server-side Rendering (SSR) is a technique where pages returned from a server
include the fully populated and loaded data of the page - and not just a
&quot;skeleton&quot; HTML page that's later populated by page scripts.</p>
              <h2 id="considerations-for-ssr"><a class="hlink" href="#considerations-for-ssr">#</a>Considerations for SSR</h2>
              <p>SSR has it's pros and cons and its use should be carefully considered.</p>
              <p>Benefits of SSR include:</p>
              <ul>
                <li>Improved SEO - some search engines can't properly index single-page apps because the crawler
only sees the empty &quot;skeleton&quot; page and not the content that should be indexed.</li>
                <li>Support for per-page social media meta information (Open Graph tags, Twitter cards)</li>
                <li>Faster initial appearance - because the page is downloaded fully populated, the page can
be presented sooner by the browser</li>
              </ul>
              <p>Downsides of SSR include:</p>
              <ul>
                <li>Increased complexity</li>
                <li>All scripts and dependent libraries need to be able to run on client and server</li>
                <li>Additional load on the server</li>
              </ul>
              <p>Often the main quoted reason for SSR is improved SEO however most major search engines
can now run page scripts and &quot;see&quot; the fully populated version of a page without using SSR.</p>
              <p>A perhaps more important reason for SSR is for the inclusion of per-page social
media meta tags - in which case a simpler solution may be to just provide those
on a per-URL basis rather than server side rendering the entire page.</p>
              <p>While there are valid reasons for wanting full SSR you should consider your requirements
carefully as it does add quite a bit of complexity - although we've tried to
make it as easy as possible with CodeOnly.</p>
              <p>Some things to consider:</p>
              <ul>
                <li>
                  <p>If your app's content is only available to authenticated users there's no point using
SSR for improved SEO - the web crawler can't see your content anyway.</p>
                </li>
                <li>
                  <p>If your app's content is static, or mostly static (eg: a blog, or documentation site)
that is infrequently updated a better choice might be <a href="renderSSG">static site generation (SSG)</a></p>
                </li>
                <li>
                  <p>If your app's content is publicly accessible, dynamically changing and requires good
SEO or social media meta info, then SSR may be the correct choice.</p>
                </li>
              </ul>
              <h2 id="technical-concepts"><a class="hlink" href="#technical-concepts">#</a>Technical Concepts</h2>
              <p>CodeOnly includes support for rendering HTML on a server where requests
for page URLs need to return fully populated and rendered HTML pages.</p>
              <p>The idea here is to use the same JavaScript components as used on the client
to also render HTML on the server.</p>
              <p>When rendering on a server, special consideration needs to be given to:</p>
              <ul>
                <li>
                  <p>Rendering multiple pages concurrently</p>
                </li>
                <li>
                  <p>Isolating multiple apps from each other</p>
                  <p>eg: suppose you use different apps for authenticated vs non-authenticates users -
anything that's global (eg: <code>css()</code> style sheet declarations, route handlers, etc...)
needs to be kept separate.</p>
                </li>
                <li>
                  <p>Waiting for async routing and async data loads to complete before rendering.</p>
                  <p>eg: if a page loads async data, the server needs to wait for the page to finish
loading that data before rendering.</p>
                </li>
              </ul>
              <h2 id="quick-start"><a class="hlink" href="#quick-start">#</a>Quick Start</h2>
              <p>The sections below describe how to set up server side rendering.</p>
              <p>To quickly get started the code generator can generate a project already
configured for SSR.</p>
              <p>With NodeJS installed, from a command line run:</p>
              <pre><code>npx codeonlyjs/cogent new fullstack MyApp
</code></pre>
              <p>By default the project is generated with SSR disabled.  To enable it, open
the <code>server/config.js</code> file, and set the <code>ssr</code> option to <code>true</code>.</p>
              <p>To confirm it's working:</p>
              <ol>
                <li>Run the project (eg: <code>npm run dev</code>)</li>
                <li>View the site in a browser (typically <code>http://localhost:3000</code>)</li>
                <li>Right click and choose &quot;View Source&quot;</li>
                <li>Check that the page content has been rendered and is present in the
source HTML.</li>
              </ol>
              <p>Most of the code relating to SSR can be found in these files:</p>
              <ul>
                <li><code>server/server.js</code> (search for &quot;ssr&quot;)</li>
                <li><code>client/main_ssr.js</code> (the main entry point when running on the server)</li>
              </ul>
              <p>Note that when using SSR, the code in the <code>client/</code> directory runs on
both the client and the server.</p>
              <h2 id="ssrworker-classes"><a class="hlink" href="#ssrworker-classes">#</a>SSRWorker Classes</h2>
              <p>There are two classes to support server side rendering:</p>
              <ul>
                <li>
                  <p><code>SSRWorker</code> - the main class responsible for loading and rendering components
and pages</p>
                </li>
                <li>
                  <p><code>SSRWorkerThread</code> - a wrapper that runs an <code>SSRWorker</code> instance on a worker thread.</p>
                </li>
              </ul>
              <p>Both classes have identical APIs with the only difference being that <code>SSRWorkerThread</code>
loads an instance of <code>SSRWorker</code> on a NodeJS Worker thread and marshals calls to it.</p>
              <p>Worker threads are the mechanism used to keep multiple server-side apps isolated.</p>
              <p>To use the <code>SSRWorkerThread</code> class, first create an instance and call its <code>init</code> method:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">SSRWorkerThread</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@codeonlyjs/core&quot;</span>;

<span class="hljs-comment">// Create and initialize worker thread</span>
<span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSRWorkerThread</span>();
<span class="hljs-keyword">await</span> worker.<span class="hljs-title function_">init</span>({
    <span class="hljs-attr">entryFile</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../client/main_ssr.js&quot;</span>), 
    <span class="hljs-attr">entryMain</span>: <span class="hljs-string">&quot;main_ssr&quot;</span>,
    entryHtml,
});
</code></pre>
              <p>The <code>init()</code> method takes an object with the following parameters:</p>
              <ul>
                <li><code>entryFile</code> - the name of the main <code>.js</code> entry point into the server-side
version of the application (see below for an example)</li>
                <li><code>entryMain</code> - the name of the exported entry point function in <code>entryFile</code></li>
                <li><code>entryHtml</code> - the app's <code>index.html</code> file loaded to a string</li>
              </ul>
              <h2 id="entryfile-and-entrymain"><a class="hlink" href="#entryfile-and-entrymain">#</a><code>entryFile</code> and <code>entryMain</code></h2>
              <p>Client side apps typically have an entry point that's called from
<code>index.html</code> to create and mount the main component, start the router etc...</p>
              <p><code>Main.js</code>:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)
{
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;body&quot;</span>);
    router.<span class="hljs-title function_">start</span>();
}
</code></pre>
              <p>In the case of server side rendering, the entry point often needs to be slightly
different and is specified using the <code>entryFile</code> and <code>entryMain</code> options
passed to the <code>SSRWorker</code>'s <code>init</code> method:</p>
              <p><code>main_ssr.js</code>:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node-fetch-native&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Main</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Main.js&quot;</span>;

globalThis.<span class="hljs-property">fetch</span> = fetch;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main_ssr</span>(<span class="hljs-params"></span>)
{
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;body&quot;</span>);
}
</code></pre>
              <p>Note the following:</p>
              <ul>
                <li>The same <code>Main</code> component is constructed and mounted to the <code>body</code> element</li>
                <li>The router doesn't need to be started as this is managed by the <code>SSRWorker</code></li>
                <li>Any server-only module dependencies can be loaded here.  In the above example
it imports <code>node-fetch-native</code> and attaches it to <code>globalThis</code>, making it
available to other parts of the application when running on the server,
just as it would be in a browser.</li>
              </ul>
              <h2 id="entryhtml"><a class="hlink" href="#entryhtml">#</a><code>entryHtml</code></h2>
              <p>In a browser environment, the entry point is called directly from the <code>index.html</code>
file.  In a server environment we need to specify the <code>index.html</code> as an HTML string
into which the mounted components will be inserted to produce the final rendered
version of the page.</p>
              <p>Often the <code>entryHtml</code> file will be the same <code>client/index.html</code> file
loaded into a string:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">let</span> entryHtml = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../client/index.html&quot;</span>), <span class="hljs-string">&quot;utf8&quot;</span>);
</code></pre>
              <h2 id="use-with-bundle-free"><a class="hlink" href="#use-with-bundle-free">#</a>Use with Bundle Free</h2>
              <p>If your server uses Bundle Free, you'll also want to inject the import maps and other
changes it provides into the <code>entryHtml</code> string.</p>
              <p>This can be managed by setting up the Bundle Free middleware slightly differently:</p>
              <ol>
                <li>Capture a reference to the middleware for later use (see the <code>bf</code> variable in
the following example)</li>
                <li>Set the <code>spa</code> option to <code>false</code> - since we'll be handling page loads ourself</li>
                <li>Set the <code>default</code> option to <code>false</code> - to prevent automatically loading <code>index.html</code>
on directory URL requests.</li>
                <li>Be sure to do this for both &quot;production&quot; and &quot;development&quot; modes.</li>
              </ol>
              <pre><code class="hljs language-js"><span class="hljs-keyword">let</span> bf;
<span class="hljs-keyword">if</span> (app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;env&#x27;</span>) === <span class="hljs-string">&#x27;production&#x27;</span>)
{
    <span class="hljs-comment">// Production</span>
    app.<span class="hljs-title function_">use</span>(bf = <span class="hljs-title function_">bundleFree</span>({
        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../client/dist&quot;</span>),
        <span class="hljs-attr">spa</span>: <span class="hljs-literal">false</span>, <span class="note"><span class="inner">disable SPA </span></span>
        <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>, <span class="note"><span class="inner">disable index.html </span></span>
    }));
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-comment">// Development</span>
    app.<span class="hljs-title function_">use</span>(bf = <span class="hljs-title function_">bundleFree</span>({
        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../client&quot;</span>),
        <span class="hljs-attr">spa</span>: <span class="hljs-literal">false</span>, <span class="note"><span class="inner">disable SPA </span></span>
        <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>, <span class="note"><span class="inner">disable index.html </span></span>
        <span class="hljs-attr">modules</span>: [ 
            <span class="hljs-string">&quot;@codeonlyjs/core&quot;</span>,
        ],
        <span class="hljs-attr">replace</span>: [
            { <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;./Main.js&quot;</span>, <span class="hljs-attr">to</span>: <span class="hljs-string">&quot;/Main.js&quot;</span> },
        ],
        <span class="hljs-comment">// etc..</span>
    }));
}
</code></pre>
              <p>We can now call <code>bf.patch_html_file</code> to load the html file and inject the import maps
and other changes into the HTML content:</p>
              <pre><code class="hljs language-js"><span class="hljs-comment">// Load index.html and inject import maps etc...</span>
<span class="hljs-keyword">let</span> entryHtml = <span class="hljs-keyword">await</span> bf.<span class="hljs-title function_">patch_html_file</span>(
    <span class="hljs-string">&quot;&quot;</span>,  <span class="note"><span class="inner">base subpath if necessary </span></span>
    path.<span class="hljs-title function_">join</span>(bf.<span class="hljs-property">options</span>.<span class="hljs-property">path</span>, <span class="hljs-string">&quot;index.html&quot;</span>) <span class="note"><span class="inner">in either ../client or ../client/dist </span></span>
);
</code></pre>
              <h2 id="rendering"><a class="hlink" href="#rendering">#</a>Rendering</h2>
              <p>Once the worker has been constructed and initialized, you can render pages
using the <code>render</code> method, passing the URL of the page to be rendered:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> worker.<span class="hljs-title function_">render</span>(url.<span class="hljs-property">href</span>);
</code></pre>
              <p>The <code>render</code> method performs the following steps:</p>
              <ol>
                <li>Sets up an <code>AsyncStorage</code> for the request with a new SSR environment
instance specific to this request. This allows multiple requests to run
concurrently while still being isolated from each other.</li>
                <li>Sets up an SSR router driver with the requested URL</li>
                <li>Calls the <code>entryMain</code> function in <code>entryFile</code> (ie: the entry point into
your application).</li>
                <li>Invokes the router to load the URL</li>
                <li>Waits for any async route and data loads to complete</li>
                <li>Ensures any invalidated components are updated</li>
                <li>Injects the rendered HTML of all mounted components and registered CSS
styles into <code>entryHtml</code>.</li>
                <li>Returns the final HTML string</li>
              </ol>
              <h2 id="expressjs-page-rendering"><a class="hlink" href="#expressjs-page-rendering">#</a>ExpressJS Page Rendering</h2>
              <p>If you're using ExpressJS as the server framework library, installing an SSR page
rendering route handler can be done as follows.</p>
              <p>This should be done after all other route handlers as we want to handle all
unknown URL's using the client application (assuming we're using normal URL paths
and not hashed URL paths).</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { prettyHtml } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@codeonlyjs/core&quot;</span>;

<span class="hljs-comment">// SPA handler</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-regexp">/\/.*/</span>, <span class="hljs-title function_">async</span> (req, res, next) =&gt; {

    <span class="hljs-comment">// Only if asking for text/html</span>
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">headers</span>.<span class="hljs-property">accept</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>).<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;text/html&quot;</span>) &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();

    <span class="hljs-comment">// Create full URL</span>
    <span class="hljs-keyword">let</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(req.<span class="hljs-property">protocol</span> + <span class="hljs-string">&#x27;://&#x27;</span> + req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;host&#x27;</span>) + req.<span class="hljs-property">originalUrl</span>);

    <span class="hljs-comment">// Render page</span>
    <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> worker.<span class="hljs-title function_">render</span>(url.<span class="hljs-property">href</span>);

    <span class="hljs-comment">// In development mode, make it pretty</span>
    <span class="hljs-keyword">if</span> (app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;env&#x27;</span>) !== <span class="hljs-string">&#x27;production&#x27;</span>)
       html = <span class="hljs-title function_">prettyHtml</span>(html);

    <span class="hljs-comment">// Send it</span>
    res.<span class="hljs-title function_">send</span>(html);

});
</code></pre>
              <h2 id="passing-data-to-ssrworker"><a class="hlink" href="#passing-data-to-ssrworker">#</a>Passing Data to SSRWorker</h2>
              <p>It is possible to pass data to <code>SSRWorker</code> both globally and on a per-render
basis.</p>
              <p>All settings passed to <code>SSRWorker.init()</code> including the <code>entryFile</code>, <code>entryMain</code>
and <code>entryHtml</code> options are available to components running in the worker
as <code>getEnv().options</code>.</p>
              <p>eg: suppose you need to pass the URL of a back-end server to be used for data
fetch requests:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">await</span> worker.<span class="hljs-title function_">init</span>({
    <span class="hljs-attr">entryFile</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../client/main_ssr.js&quot;</span>), 
    <span class="hljs-attr">entryMain</span>: <span class="hljs-string">&quot;main_ssr&quot;</span>,
    entryHtml,
    <span class="hljs-attr">backEndApiServer</span>: <span class="hljs-string">&quot;http://localhost:3005/api&quot;</span>,
});
</code></pre>
              <p>A component being rendered could then access that setting via <code>getEnv().options</code>:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>
{
    <span class="hljs-title function_">refresh</span>(<span class="hljs-params"></span>)
    {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">load</span>(<span class="hljs-title function_">async</span> () =&gt; {
            <span class="hljs-keyword">let</span> url = <span class="hljs-title function_">getEnv</span>().<span class="hljs-property">options</span>.<span class="hljs-property">backEndApiServer</span> + <span class="hljs-string">&quot;/user/...&quot;</span>;
            <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
        });
    }
}
</code></pre>
              <p>Similarly, per-request data can be passed as a second parameter to the render
method:</p>
              <p>eg: passing the id of a logged in user</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> worker.<span class="hljs-title function_">render</span>(url, {
    <span class="hljs-attr">userId</span>: currentUser.<span class="hljs-property">id</span>,
});
</code></pre>
              <p>The values passed as the second parameter are merged over a copy of the original
SSRWorker options and can be accessed in the same way:</p>
              <pre><code class="hljs language-js"><span class="hljs-keyword">let</span> userId = <span class="hljs-title function_">getEnv</span>().<span class="hljs-property">options</span>.<span class="hljs-property">userId</span>;
</code></pre>
              <p>When using <code>SSRWorkerThread</code> any values passed to the worker thread need to be
compatible with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clone algorithm</a>
since they're passed via Node's <a href="https://nodejs.org/api/worker_threads.html#portpostmessagevalue-transferlist"><code>postMessage</code></a>
function.</p>
              <h2 id="hydration"><a class="hlink" href="#hydration">#</a>Hydration</h2>
              <p>Hydration refers to the client side process of connecting the DOM elements loaded from the
SSR rendered HTML page with DOM elements created by scripted components.</p>
              <p>Some frameworks solve this by trying to marry up the DOM elements created from
the SSR rendered page with elements constructed by script in the single page app.</p>
              <p>CodeOnly takes a simpler approach:</p>
              <ol>
                <li>The page is loaded as per usual (with all SSR content intact)</li>
                <li>The app's main entry point is invoked, components mounted, CSS registered etc...</li>
                <li>However... if the page was rendered by SSR, any changes to the DOM are delayed until the initial
load is complete - including waiting for router navigation, async data loads, <code>nextFrame()</code>
callbacks etc...</li>
                <li>Once the initial load is complete, all SSR rendered content is removed and replaced
by the script generated content.</li>
              </ol>
              <p>While this approach is somewhat naive it's considerably simpler, very reliable and has
few (if any) downsides over a more complicated approach.</p>
              <p>To support the above, the <code>SSRWorker</code> makes some additional injections
into the rendered HTML:</p>
              <ul>
                <li>
                  <p>A meta tag indicating the page was SSR rendered:</p>
                  <pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;co-ssr&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
</code></pre>
                </li>
                <li>
                  <p>Comments to delimit any SSR rendered content that needs be removed (this includes
mounted components and registered CSS styles):</p>
                  <pre><code class="hljs language-html"><span class="hljs-comment">&lt;!--co-ssr-start--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    This div was server-side rendered and will be replaced
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-comment">&lt;!--co-ssr-end--&gt;</span>    
</code></pre>
                </li>
              </ul>
            </div>
            <nav class="next-previous-navigation"><a class="previous" href="renderIntro"><div class="description muted">‹ Previous</div><div class="title">Introduction to Rendering</div></a><a class="next" href="renderSSG"><div class="description muted">Next ›</div><div class="title">Static Site Generation</div></a></nav>
          </div>
          <div id="div-rhs" class="">
            <nav id="secondary-nav">
              <div class="highlight"></div>
              <a href="#" class="title">Server Side Rendering</a>
              <ul class="h1">
                <!-- enter foreach block -->
                <li><a href="#considerations-for-ssr">Considerations for SSR</a><!-- IfBlock placeholder --></li>
                <li><a href="#technical-concepts">Technical Concepts</a><!-- IfBlock placeholder --></li>
                <li><a href="#quick-start">Quick Start</a><!-- IfBlock placeholder --></li>
                <li><a href="#ssrworker-classes">SSRWorker Classes</a><!-- IfBlock placeholder --></li>
                <li><a href="#entryfile-and-entrymain">entryFile and entryMain</a><!-- IfBlock placeholder --></li>
                <li><a href="#entryhtml">entryHtml</a><!-- IfBlock placeholder --></li>
                <li><a href="#use-with-bundle-free">Use with Bundle Free</a><!-- IfBlock placeholder --></li>
                <li><a href="#rendering">Rendering</a><!-- IfBlock placeholder --></li>
                <li><a href="#expressjs-page-rendering">ExpressJS Page Rendering</a><!-- IfBlock placeholder --></li>
                <li><a href="#passing-data-to-ssrworker">Passing Data to SSRWorker</a><!-- IfBlock placeholder --></li>
                <li><a href="#hydration">Hydration</a><!-- IfBlock placeholder --></li>
                <!-- leave foreach block -->
              </ul>
            </nav>
          </div>
        </div>
      </div>
    </div>
    <!--co-ssr-end-->
  </body>
</html>
